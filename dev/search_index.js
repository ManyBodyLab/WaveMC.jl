var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#WaveMC.WaveMC","page":"Reference","title":"WaveMC.WaveMC","text":"Allocation-free Quantum Monte Carlo for arbitrary wave functions  and observables in Julia, built on the Carlo.jl framework.\n\n\n\n\n\n","category":"module"},{"location":"reference/#WaveMC.AbstractObservables","page":"Reference","title":"WaveMC.AbstractObservables","text":"AbstractObservables\n\nDefines an interface to measure arbitrary observables during Monte Carlo simulations. Observables can be provided by defining a new struct: struct YourObservablesType <: AbstractObservables     # Your fields here end and overloading Carlo.measure!(mc::AbstractWavefunctionMC, ctx::MCContext, obs::YourObservablesType).\n\nAlternatively, you can also create a BufferedObservables instance, which supports buffering intermediate results (provided via buffer and buffer_functions). E.g. one can use this to calculate the pairwise distances between particles and then use these distances to compute observables. The observables themselves can be provided as name => function or as a struct <= Observables. As a function, the signature should be     f(bareposition, position, buffer) -> value where bareposition is the raw position of the particles, position is the transformed position (after applying the coordinate_transformer) and buffer is a tuple of all buffers.\n\nAs a struct, you need to overload     Carlo.measure!(mc::AbstractWavefunctionMC, ctx::MCContext, obs::YourObservableStruct, bare_position, position, buffer).\n\n\n\n\n\n","category":"type"},{"location":"reference/#WaveMC.AbstractWavefunction","page":"Reference","title":"WaveMC.AbstractWavefunction","text":"AbstractWavefunction\n\nThis abstract type defines the interface for wavefunction objects used in Monte Carlo simulations. Concrete implementations must provide the following methods:\n\n(psi)(x): Evaluates the wavefunction at the given coordinates x.\ninputtype(YourWavefunctionType): Returns the data type of the input coordinates (e.g., Float64, ComplexF64, Tuple{Float64, Float64}).\ninputlength(YourWavefunctionType): Returns the number of coordinates the wavefunction takes as input.\n\nOptional methods are:\n\ncoordinate_projector(YourWavefunctionType): Returns a function that projects coordinates into the valid domain for the wavefunction. Defaults to the identity function.\ncoordinate_transformer(YourWavefunctionType): Returns a function that transforms coordinates before they are used in the wavefunction. Defaults to the identity function.\n\nMethods which should be overloaded for improved performance:\n\nlogdensity(psi::YourWavefunctionType, x): Computes the logarithm of the probability density at coordinates x, corresponds to log(abs2(psi(x))).\ndelta_logdensity(psi::YourWavefunctionType, xnew::AbstractVector, xold::AbstractVector): Computes the change in log-density between new and old coordinates.\ndelta_logdensity(psi::YourWavefunctionType, xnew, xold::AbstractVector, dim::Int): Computes the change in log-density when only the coordinate at index dim is changed.\n\n\n\n\n\n","category":"type"},{"location":"reference/#WaveMC.AbstractWavefunctionMC","page":"Reference","title":"WaveMC.AbstractWavefunctionMC","text":"AbstractWavefunctionMC{N}\n\nAbstract type for wavefunction-based Monte Carlo methods with N coordinates.\n\nFunctions to be implemented for concrete subtypes:\n\nstate(mc::AbstractWavefunctionMC): Returns the state of the Monte Carlo simulation.\ndistribution(mc::AbstractWavefunctionMC): Returns the proposal distribution used for updates.\nwavefunction(mc::AbstractWavefunctionMC): Returns the wavefunction used in the simulation.\nobservables(mc::AbstractWavefunctionMC): Returns the observables to be measured.\ndynamicpositions(mc::AbstractWavefunctionMC{N}): Returns a tuple (Nactive, dynamic_pos) indicating the number of active positions and their indices.\nacceptancerateadapter(mc::AbstractWavefunctionMC): Returns the acceptance rate adapter used for adapting the proposal distribution. (defaults to NoAcceptanceAdapter)\nchangedistribution!(mc::AbstractWavefunctionMC, newdist::Distribution): Changes the proposal distribution to newdist. (Only necessary for acceptancerate_adapter)\n\n\n\n\n\n","category":"type"},{"location":"reference/#WaveMC.Buffer","page":"Reference","title":"WaveMC.Buffer","text":"Buffer{T, A<:AbstractVector{T}, G}\n\nis a wrapper around a AbstractVector{T} that applies a mapping G to values before storing them in the buffer.\n\nFields:\n\nbuffer::A: The underlying dense vector buffer.\nmap::G: A function that transforms values before they are stored in the buffer. Defaults to the identity function.\n\nThis structure allows for efficient storage and retrieval of values with an optional transformation applied during storage.\n\n\n\n\n\n","category":"type"},{"location":"reference/#WaveMC.ComplexNormal","page":"Reference","title":"WaveMC.ComplexNormal","text":"ComplexNormal(μ, σ²)\n\nCircularly symmetric complex normal distribution with mean μ and variance σ². The real and imaginary parts are independent N(Re(μ), σ²/2) and N(Im(μ), σ²/2).\n\n\n\n\n\n","category":"type"},{"location":"reference/#WaveMC.WavefunctionMC","page":"Reference","title":"WaveMC.WavefunctionMC","text":"WavefunctionMC\n\nMain type to run wavefunction-based Monte Carlo simulations.\n\n\n\n\n\n","category":"type"},{"location":"index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"#WaveMC.jl","page":"Home","title":"WaveMC.jl","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"The package is not yet registered in the Julia general registry. It can be installed trough the package manager with the following command:\n\npkg> add git@github.com:ManyBodyLab/WaveMC.jl.git","category":"section"},{"location":"#Code-Samples","page":"Home","title":"Code Samples","text":"julia> using WaveMC","category":"section"},{"location":"#License","page":"Home","title":"License","text":"WaveMC.jl is licensed under the MIT License). By using or interacting with this software in any way, you agree to the license of this software.\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
